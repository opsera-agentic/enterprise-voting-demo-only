# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# BOOTSTRAP INFRASTRUCTURE - sperivote11
# Touchless: Terraform ‚Üí Update Manifests ‚Üí Apply ArgoCD
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

name: "00-Bootstrap (sperivote11)"

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action'
        type: choice
        options: [plan, apply, destroy]
        default: 'apply'
      skip_terraform:
        description: 'Skip Terraform (ArgoCD only)'
        type: boolean
        default: false

env:
  APP_NAME: sperivote11
  ENVIRONMENT: dev
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np

jobs:
  terraform:
    name: "üèóÔ∏è Terraform"
    runs-on: ubuntu-latest
    if: inputs.skip_terraform != true
    outputs:
      rds_address: ${{ steps.output.outputs.rds_address }}
      redis_address: ${{ steps.output.outputs.redis_address }}
      vote_irsa: ${{ steps.output.outputs.vote_irsa }}
      result_irsa: ${{ steps.output.outputs.result_irsa }}
      worker_irsa: ${{ steps.output.outputs.worker_irsa }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"

      - name: Terraform Init
        working-directory: .opsera-sperivote11/terraform
        run: terraform init -backend-config="key=sperivote11/dev/terraform.tfstate"

      - name: Terraform Plan
        working-directory: .opsera-sperivote11/terraform
        run: terraform plan -var-file="dev.tfvars" -out=tfplan

      - name: Terraform Apply
        if: inputs.action == 'apply'
        working-directory: .opsera-sperivote11/terraform
        run: terraform apply -auto-approve tfplan

      - name: Get Outputs
        id: output
        if: inputs.action == 'apply'
        working-directory: .opsera-sperivote11/terraform
        run: |
          echo "rds_address=$(terraform output -raw rds_address)" >> $GITHUB_OUTPUT
          echo "redis_address=$(terraform output -raw elasticache_endpoint)" >> $GITHUB_OUTPUT
          echo "vote_irsa=$(terraform output -raw irsa_vote_role_arn)" >> $GITHUB_OUTPUT
          echo "result_irsa=$(terraform output -raw irsa_result_role_arn)" >> $GITHUB_OUTPUT
          echo "worker_irsa=$(terraform output -raw irsa_worker_role_arn)" >> $GITHUB_OUTPUT

      - name: Summary
        if: inputs.action == 'apply'
        run: |
          echo "### üèóÔ∏è Infrastructure Created" >> $GITHUB_STEP_SUMMARY
          echo "- RDS: \`${{ steps.output.outputs.rds_address }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- Redis: \`${{ steps.output.outputs.redis_address }}\`" >> $GITHUB_STEP_SUMMARY

  update-manifests:
    name: "üìù Update Manifests"
    needs: [terraform]
    if: always() && (needs.terraform.result == 'success' || inputs.skip_terraform == true) && inputs.action == 'apply'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: hashicorp/setup-terraform@v3

      - name: Get Terraform Outputs
        id: tf
        working-directory: .opsera-sperivote11/terraform
        run: |
          terraform init -backend-config="key=sperivote11/dev/terraform.tfstate"
          echo "rds_address=$(terraform output -raw rds_address)" >> $GITHUB_OUTPUT
          echo "redis_address=$(terraform output -raw elasticache_endpoint)" >> $GITHUB_OUTPUT
          echo "vote_irsa=$(terraform output -raw irsa_vote_role_arn)" >> $GITHUB_OUTPUT
          echo "result_irsa=$(terraform output -raw irsa_result_role_arn)" >> $GITHUB_OUTPUT
          echo "worker_irsa=$(terraform output -raw irsa_worker_role_arn)" >> $GITHUB_OUTPUT

      - name: Update ConfigMap
        run: |
          sed -i "s|PLACEHOLDER_REDIS_HOST|${{ steps.tf.outputs.redis_address }}|g" .opsera-sperivote11/k8s/overlays/dev/configmap.yaml
          sed -i "s|PLACEHOLDER_DATABASE_HOST|${{ steps.tf.outputs.rds_address }}|g" .opsera-sperivote11/k8s/overlays/dev/configmap.yaml

      - name: Update ServiceAccounts
        run: |
          sed -i "s|PLACEHOLDER_VOTE_IRSA_ROLE|${{ steps.tf.outputs.vote_irsa }}|g" .opsera-sperivote11/k8s/overlays/dev/serviceaccounts.yaml
          sed -i "s|PLACEHOLDER_RESULT_IRSA_ROLE|${{ steps.tf.outputs.result_irsa }}|g" .opsera-sperivote11/k8s/overlays/dev/serviceaccounts.yaml
          sed -i "s|PLACEHOLDER_WORKER_IRSA_ROLE|${{ steps.tf.outputs.worker_irsa }}|g" .opsera-sperivote11/k8s/overlays/dev/serviceaccounts.yaml

      - name: Update ECR Registry
        run: |
          ECR="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
          sed -i "s|PLACEHOLDER_ECR_REGISTRY|${ECR}|g" .opsera-sperivote11/k8s/overlays/dev/kustomization.yaml

      - name: Commit & Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .opsera-sperivote11/k8s/
          git diff --cached --quiet || git commit -m "bootstrap(sperivote11): Configure DEV manifests [skip ci]"
          git pull --rebase origin main
          git push origin main

  init-database:
    name: "üóÑÔ∏è Initialize Database"
    needs: [terraform, update-manifests]
    if: always() && (needs.terraform.result == 'success' || inputs.skip_terraform == true) && needs.update-manifests.result == 'success' && inputs.action == 'apply'
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - uses: hashicorp/setup-terraform@v3

      - uses: actions/checkout@v4

      - name: Get RDS Endpoint
        id: rds
        working-directory: .opsera-sperivote11/terraform
        run: |
          terraform init -backend-config="key=sperivote11/dev/terraform.tfstate"
          echo "host=$(terraform output -raw rds_address)" >> $GITHUB_OUTPUT

      - name: Setup kubectl for SPOKE cluster
        run: aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Create IAM Database User via K8s Job
        env:
          RDS_HOST: ${{ steps.rds.outputs.host }}
          DB_PASSWORD: ${{ secrets.RDS_MASTER_PASSWORD }}
        run: |
          # Create namespace if not exists
          kubectl create namespace ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} --dry-run=client -o yaml | kubectl apply -f -

          # Delete old job if exists
          kubectl delete job db-init-${{ env.APP_NAME }} -n ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} --ignore-not-found

          # Create and run database init job inside the cluster (has VPC access to RDS)
          cat <<EOF | kubectl apply -f -
          apiVersion: batch/v1
          kind: Job
          metadata:
            name: db-init-${{ env.APP_NAME }}
            namespace: ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}
          spec:
            ttlSecondsAfterFinished: 300
            template:
              spec:
                restartPolicy: Never
                containers:
                - name: psql
                  image: postgres:15-alpine
                  env:
                  - name: PGPASSWORD
                    value: "${DB_PASSWORD}"
                  - name: PGHOST
                    value: "${RDS_HOST}"
                  - name: PGUSER
                    value: "postgres_admin"
                  - name: PGDATABASE
                    value: "votes"
                  command:
                  - /bin/sh
                  - -c
                  - |
                    echo "Connecting to RDS at \${PGHOST}..."
                    psql -c "
                    -- Create app_user if not exists
                    DO \\\$\\\$
                    BEGIN
                      IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = 'app_user') THEN
                        CREATE USER app_user WITH LOGIN;
                        RAISE NOTICE 'Created user app_user';
                      ELSE
                        RAISE NOTICE 'User app_user already exists';
                      END IF;
                    END
                    \\\$\\\$;

                    -- Grant IAM authentication
                    GRANT rds_iam TO app_user;

                    -- Grant permissions
                    GRANT ALL PRIVILEGES ON DATABASE votes TO app_user;
                    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO app_user;
                    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO app_user;
                    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO app_user;
                    ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO app_user;
                    "

                    echo "Verifying user creation..."
                    psql -c "SELECT usename, usesuper, usecreatedb FROM pg_user WHERE usename = 'app_user';"
                    echo "‚úÖ Database user app_user configured successfully"
          EOF

          # Wait for job to complete
          echo "Waiting for database init job to complete..."
          kubectl wait --for=condition=complete job/db-init-${{ env.APP_NAME }} -n ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} --timeout=120s

          # Show job logs
          kubectl logs job/db-init-${{ env.APP_NAME }} -n ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}

          echo "‚úÖ Database user app_user created with IAM auth" >> $GITHUB_STEP_SUMMARY

  apply-argocd:
    name: "üöÄ Apply ArgoCD"
    needs: [update-manifests, init-database]
    if: always() && needs.update-manifests.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: main

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        run: aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Create Repo Secret
        run: |
          kubectl get secret repo-${{ env.APP_NAME }} -n argocd 2>/dev/null || \
          kubectl create secret generic repo-${{ env.APP_NAME }} -n argocd \
            --from-literal=type=git \
            --from-literal=url="https://github.com/${{ github.repository }}.git" \
            --from-literal=password="${{ secrets.GH_PAT }}" \
            --from-literal=username="git"
          kubectl label secret repo-${{ env.APP_NAME }} -n argocd argocd.argoproj.io/secret-type=repository --overwrite

      - name: Apply ArgoCD App
        run: kubectl apply -f .opsera-sperivote11/argocd/dev/application.yaml

      - name: Trigger Sync
        run: |
          kubectl annotate application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd argocd.argoproj.io/refresh=hard --overwrite
          echo "‚úÖ ArgoCD app applied and sync triggered" >> $GITHUB_STEP_SUMMARY

      - name: Wait for Sync
        run: |
          for i in {1..30}; do
            STATUS=$(kubectl get application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            echo "Sync: $STATUS"
            [ "$STATUS" == "Synced" ] && exit 0
            sleep 10
          done
          echo "‚ö†Ô∏è Sync still in progress"
