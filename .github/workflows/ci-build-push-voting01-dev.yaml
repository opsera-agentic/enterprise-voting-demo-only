# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CI BUILD & DEPLOY - voting01 DEV
# Security: Gitleaks + Grype | Quality: SonarQube | Notify: Slack + Jira
# Enhanced with Prometheus, improved Slack & SonarQube integration
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "CI Build (voting01-dev)"

on:
  workflow_dispatch:
    inputs:
      security_scan_mode:
        description: 'Security scan behavior'
        type: choice
        options: ['fail', 'warn', 'skip']
        default: 'warn'
      quality_gate_mode:
        description: 'Quality gate behavior'
        type: choice
        options: ['blocking', 'non-blocking', 'skip']
        default: 'non-blocking'
      notify_on:
        description: 'When to send notifications'
        type: choice
        options: ['always', 'failure', 'success', 'never']
        default: 'always'
      runner:
        description: 'Runner type'
        type: choice
        options: ['github-hosted', 'self-hosted']
        default: 'github-hosted'
  push:
    branches: [main]
    paths:
      - 'vote/**'
      - 'result/**'
      - 'worker/**'
      - '.opsera-voting01/**'

env:
  APP_NAME: voting01
  ENVIRONMENT: dev
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np

permissions:
  contents: write
  security-events: write
  pull-requests: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SECURITY SCANNING
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  security-gitleaks:
    name: "ðŸ”’ Security Scan"
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    if: github.event.inputs.security_scan_mode != 'skip'
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4

      - name: Security Scan Status
        run: |
          echo "### ðŸ”’ Security Scan" >> $GITHUB_STEP_SUMMARY
          echo "âœ… Security scanning configured" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Note:** Gitleaks requires a license for organization repos." >> $GITHUB_STEP_SUMMARY
          echo "Container scanning (Grype) runs during the build stage." >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # QUALITY GATES - SonarQube with Quality Gate Status
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  quality-sonarqube:
    name: "ðŸ“Š SonarQube"
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    if: github.event.inputs.quality_gate_mode != 'skip'
    continue-on-error: ${{ github.event.inputs.quality_gate_mode != 'blocking' }}
    outputs:
      quality_gate_status: ${{ steps.quality-gate.outputs.status }}
      sonar_url: ${{ steps.quality-gate.outputs.dashboard_url }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check SonarQube Configuration
        id: check-sonar
        run: |
          if [ -n "${{ secrets.SONAR_TOKEN }}" ] && [ -n "${{ secrets.SONAR_HOST_URL }}" ]; then
            echo "configured=true" >> $GITHUB_OUTPUT
            echo "âœ… SonarQube secrets configured" >> $GITHUB_STEP_SUMMARY
          else
            echo "configured=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ SonarQube secrets not configured - skipping scan" >> $GITHUB_STEP_SUMMARY
            echo "Required secrets: SONAR_TOKEN, SONAR_HOST_URL" >> $GITHUB_STEP_SUMMARY
          fi

      - name: SonarQube Scan
        if: steps.check-sonar.outputs.configured == 'true'
        uses: sonarsource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.projectKey=opsera-voting01
            -Dsonar.projectName=voting01
            -Dsonar.sources=vote,result,worker
            -Dsonar.python.version=3.9
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info
            -Dsonar.qualitygate.wait=true

      - name: Check Quality Gate Status
        id: quality-gate
        if: steps.check-sonar.outputs.configured == 'true'
        run: |
          # Get quality gate status from SonarQube
          SONAR_HOST="${{ secrets.SONAR_HOST_URL }}"
          PROJECT_KEY="opsera-voting01"
          
          RESPONSE=$(curl -s -u "${{ secrets.SONAR_TOKEN }}:" \
            "${SONAR_HOST}/api/qualitygates/project_status?projectKey=${PROJECT_KEY}" || echo '{"projectStatus":{"status":"UNKNOWN"}}')
          
          STATUS=$(echo "$RESPONSE" | jq -r '.projectStatus.status // "UNKNOWN"')
          echo "status=${STATUS}" >> $GITHUB_OUTPUT
          echo "dashboard_url=${SONAR_HOST}/dashboard?id=${PROJECT_KEY}" >> $GITHUB_OUTPUT
          
          echo "### ðŸ“Š SonarQube Quality Gate" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$STATUS" = "OK" ]; then
            echo "âœ… **Status: PASSED**" >> $GITHUB_STEP_SUMMARY
          elif [ "$STATUS" = "ERROR" ]; then
            echo "âŒ **Status: FAILED**" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ **Status: ${STATUS}**" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "[View Dashboard](${SONAR_HOST}/dashboard?id=${PROJECT_KEY})" >> $GITHUB_STEP_SUMMARY
          
          # Fail if blocking mode and quality gate failed
          if [ "${{ github.event.inputs.quality_gate_mode }}" = "blocking" ] && [ "$STATUS" = "ERROR" ]; then
            echo "âŒ Quality gate failed in blocking mode"
            exit 1
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BUILD & PUSH
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  build:
    name: "ðŸ—ï¸ Build & Push"
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    needs: [security-gitleaks, quality-sonarqube]
    if: always() && !contains(needs.*.result, 'failure')
    outputs:
      image_tag: ${{ steps.tag.outputs.tag }}
      has_security_findings: ${{ steps.security-summary.outputs.has_security_findings }}
      total_critical: ${{ steps.security-summary.outputs.total_critical }}
      total_high: ${{ steps.security-summary.outputs.total_high }}
      vote_critical: ${{ steps.parse-vote.outputs.critical }}
      vote_high: ${{ steps.parse-vote.outputs.high }}
      result_critical: ${{ steps.parse-result.outputs.critical }}
      result_high: ${{ steps.parse-result.outputs.high }}
      worker_critical: ${{ steps.parse-worker.outputs.critical }}
      worker_high: ${{ steps.parse-worker.outputs.high }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
          docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      - name: Generate Tag
        id: tag
        run: |
          TAG="$(git rev-parse --short HEAD)-$(date +%Y%m%d%H%M%S)"
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
          echo "### ðŸ·ï¸ Image Tag: \`${TAG}\`" >> $GITHUB_STEP_SUMMARY

      - name: Build Vote
        id: build-vote
        run: |
          ECR="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/opsera/${{ env.APP_NAME }}-vote"
          docker build -f .opsera-voting01/Dockerfiles/Dockerfile.vote -t ${ECR}:${{ steps.tag.outputs.tag }} .
          echo "image=${ECR}:${{ steps.tag.outputs.tag }}" >> $GITHUB_OUTPUT

      - name: Grype Scan Vote
        id: grype-vote
        if: github.event.inputs.security_scan_mode != 'skip'
        uses: anchore/scan-action@v3
        continue-on-error: true
        with:
          image: ${{ steps.build-vote.outputs.image }}
          fail-build: ${{ github.event.inputs.security_scan_mode == 'fail' }}
          severity-cutoff: high
          output-format: json
          output-file: grype-vote-results.json

      - name: Parse Vote Vulnerabilities
        id: parse-vote
        if: github.event.inputs.security_scan_mode != 'skip'
        run: |
          if [ -f grype-vote-results.json ]; then
            CRITICAL=$(jq '[.matches[] | select(.vulnerability.severity == "Critical")] | length' grype-vote-results.json 2>/dev/null || echo "0")
            HIGH=$(jq '[.matches[] | select(.vulnerability.severity == "High")] | length' grype-vote-results.json 2>/dev/null || echo "0")
            echo "critical=${CRITICAL}" >> $GITHUB_OUTPUT
            echo "high=${HIGH}" >> $GITHUB_OUTPUT
            echo "### ðŸ”’ Vote Security Scan Results" >> $GITHUB_STEP_SUMMARY
            echo "- Critical: ${CRITICAL}" >> $GITHUB_STEP_SUMMARY
            echo "- High: ${HIGH}" >> $GITHUB_STEP_SUMMARY
            if [ "$CRITICAL" -gt 0 ] || [ "$HIGH" -gt 0 ]; then
              echo "has_vulns=true" >> $GITHUB_OUTPUT
            else
              echo "has_vulns=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "critical=0" >> $GITHUB_OUTPUT
            echo "high=0" >> $GITHUB_OUTPUT
            echo "has_vulns=false" >> $GITHUB_OUTPUT
          fi

      - name: Push Vote
        run: |
          ECR="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/opsera/${{ env.APP_NAME }}-vote"
          docker push ${ECR}:${{ steps.tag.outputs.tag }}
          echo "âœ… Vote pushed" >> $GITHUB_STEP_SUMMARY

      - name: Build Result
        id: build-result
        run: |
          ECR="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/opsera/${{ env.APP_NAME }}-result"
          docker build -f .opsera-voting01/Dockerfiles/Dockerfile.result -t ${ECR}:${{ steps.tag.outputs.tag }} .
          echo "image=${ECR}:${{ steps.tag.outputs.tag }}" >> $GITHUB_OUTPUT

      - name: Grype Scan Result
        id: grype-result
        if: github.event.inputs.security_scan_mode != 'skip'
        uses: anchore/scan-action@v3
        continue-on-error: true
        with:
          image: ${{ steps.build-result.outputs.image }}
          fail-build: ${{ github.event.inputs.security_scan_mode == 'fail' }}
          severity-cutoff: high
          output-format: json
          output-file: grype-result-results.json

      - name: Parse Result Vulnerabilities
        id: parse-result
        if: github.event.inputs.security_scan_mode != 'skip'
        run: |
          if [ -f grype-result-results.json ]; then
            CRITICAL=$(jq '[.matches[] | select(.vulnerability.severity == "Critical")] | length' grype-result-results.json 2>/dev/null || echo "0")
            HIGH=$(jq '[.matches[] | select(.vulnerability.severity == "High")] | length' grype-result-results.json 2>/dev/null || echo "0")
            echo "critical=${CRITICAL}" >> $GITHUB_OUTPUT
            echo "high=${HIGH}" >> $GITHUB_OUTPUT
            echo "### ðŸ”’ Result Security Scan Results" >> $GITHUB_STEP_SUMMARY
            echo "- Critical: ${CRITICAL}" >> $GITHUB_STEP_SUMMARY
            echo "- High: ${HIGH}" >> $GITHUB_STEP_SUMMARY
            if [ "$CRITICAL" -gt 0 ] || [ "$HIGH" -gt 0 ]; then
              echo "has_vulns=true" >> $GITHUB_OUTPUT
            else
              echo "has_vulns=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "critical=0" >> $GITHUB_OUTPUT
            echo "high=0" >> $GITHUB_OUTPUT
            echo "has_vulns=false" >> $GITHUB_OUTPUT
          fi

      - name: Push Result
        run: |
          ECR="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/opsera/${{ env.APP_NAME }}-result"
          docker push ${ECR}:${{ steps.tag.outputs.tag }}
          echo "âœ… Result pushed" >> $GITHUB_STEP_SUMMARY

      - name: Build Worker
        id: build-worker
        run: |
          ECR="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/opsera/${{ env.APP_NAME }}-worker"
          docker build -f .opsera-voting01/Dockerfiles/Dockerfile.worker -t ${ECR}:${{ steps.tag.outputs.tag }} .
          echo "image=${ECR}:${{ steps.tag.outputs.tag }}" >> $GITHUB_OUTPUT

      - name: Grype Scan Worker
        id: grype-worker
        if: github.event.inputs.security_scan_mode != 'skip'
        uses: anchore/scan-action@v3
        continue-on-error: true
        with:
          image: ${{ steps.build-worker.outputs.image }}
          fail-build: ${{ github.event.inputs.security_scan_mode == 'fail' }}
          severity-cutoff: high
          output-format: json
          output-file: grype-worker-results.json

      - name: Parse Worker Vulnerabilities
        id: parse-worker
        if: github.event.inputs.security_scan_mode != 'skip'
        run: |
          if [ -f grype-worker-results.json ]; then
            CRITICAL=$(jq '[.matches[] | select(.vulnerability.severity == "Critical")] | length' grype-worker-results.json 2>/dev/null || echo "0")
            HIGH=$(jq '[.matches[] | select(.vulnerability.severity == "High")] | length' grype-worker-results.json 2>/dev/null || echo "0")
            echo "critical=${CRITICAL}" >> $GITHUB_OUTPUT
            echo "high=${HIGH}" >> $GITHUB_OUTPUT
            echo "### ðŸ”’ Worker Security Scan Results" >> $GITHUB_STEP_SUMMARY
            echo "- Critical: ${CRITICAL}" >> $GITHUB_STEP_SUMMARY
            echo "- High: ${HIGH}" >> $GITHUB_STEP_SUMMARY
            if [ "$CRITICAL" -gt 0 ] || [ "$HIGH" -gt 0 ]; then
              echo "has_vulns=true" >> $GITHUB_OUTPUT
            else
              echo "has_vulns=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "critical=0" >> $GITHUB_OUTPUT
            echo "high=0" >> $GITHUB_OUTPUT
            echo "has_vulns=false" >> $GITHUB_OUTPUT
          fi

      - name: Aggregate Security Findings
        id: security-summary
        if: github.event.inputs.security_scan_mode != 'skip'
        run: |
          VOTE_CRIT="${{ steps.parse-vote.outputs.critical }}"
          VOTE_HIGH="${{ steps.parse-vote.outputs.high }}"
          RESULT_CRIT="${{ steps.parse-result.outputs.critical }}"
          RESULT_HIGH="${{ steps.parse-result.outputs.high }}"
          WORKER_CRIT="${{ steps.parse-worker.outputs.critical }}"
          WORKER_HIGH="${{ steps.parse-worker.outputs.high }}"

          TOTAL_CRIT=$((${VOTE_CRIT:-0} + ${RESULT_CRIT:-0} + ${WORKER_CRIT:-0}))
          TOTAL_HIGH=$((${VOTE_HIGH:-0} + ${RESULT_HIGH:-0} + ${WORKER_HIGH:-0}))

          echo "total_critical=${TOTAL_CRIT}" >> $GITHUB_OUTPUT
          echo "total_high=${TOTAL_HIGH}" >> $GITHUB_OUTPUT

          if [ "$TOTAL_CRIT" -gt 0 ] || [ "$TOTAL_HIGH" -gt 0 ]; then
            echo "has_security_findings=true" >> $GITHUB_OUTPUT
            echo "### âš ï¸ Security Findings Summary" >> $GITHUB_STEP_SUMMARY
            echo "**Total Critical:** ${TOTAL_CRIT}" >> $GITHUB_STEP_SUMMARY
            echo "**Total High:** ${TOTAL_HIGH}" >> $GITHUB_STEP_SUMMARY
          else
            echo "has_security_findings=false" >> $GITHUB_OUTPUT
            echo "### âœ… No Critical/High Vulnerabilities Found" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Push Worker
        run: |
          ECR="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/opsera/${{ env.APP_NAME }}-worker"
          docker push ${ECR}:${{ steps.tag.outputs.tag }}
          echo "âœ… Worker pushed" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # DEPLOY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  deploy:
    name: "ðŸš€ Deploy"
    needs: [build]
    if: always() && needs.build.result == 'success'
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    outputs:
      success: ${{ steps.verify.outputs.success }}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Update Kustomization
        run: |
          cd .opsera-voting01/k8s/overlays/${{ env.ENVIRONMENT }}
          sed -i "s|newTag:.*|newTag: ${{ needs.build.outputs.image_tag }}|g" kustomization.yaml

      - name: Commit & Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .opsera-voting01/
          git diff --cached --quiet || git commit -m "deploy(voting01-dev): ${{ needs.build.outputs.image_tag }} [skip ci]"
          git pull --rebase origin main
          git push origin main

      - name: Configure AWS
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup New Relic Secret
        env:
          NEW_RELIC_LICENSE_KEY: ${{ secrets.NEW_RELIC_LICENSE_KEY }}
        run: |
          if [ -z "$NEW_RELIC_LICENSE_KEY" ]; then
            echo "âš ï¸ NEW_RELIC_LICENSE_KEY not configured - skipping New Relic setup" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}
          NS="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"

          # Create namespace if it doesn't exist
          kubectl get namespace $NS || kubectl create namespace $NS

          # Create or update the New Relic license secret
          kubectl create secret generic newrelic-license \
            --from-literal=NEW_RELIC_LICENSE_KEY="$NEW_RELIC_LICENSE_KEY" \
            --namespace=$NS \
            --dry-run=client -o yaml | kubectl apply -f -

          echo "âœ… New Relic secret configured for $NS" >> $GITHUB_STEP_SUMMARY

      - name: Trigger ArgoCD Sync
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}
          kubectl annotate application ${{ env.APP_NAME }}-${{ env.ENVIRONMENT }} -n argocd argocd.argoproj.io/refresh=hard --overwrite

      - name: Verify Deployment
        id: verify
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}
          NS="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"

          for i in {1..40}; do
            VOTE=$(kubectl get deploy vote -n $NS -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            RESULT=$(kubectl get deploy result -n $NS -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            WORKER=$(kubectl get deploy worker -n $NS -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")

            echo "Vote: ${VOTE:-0}, Result: ${RESULT:-0}, Worker: ${WORKER:-0}"

            if [ "${VOTE:-0}" -ge 1 ] && [ "${RESULT:-0}" -ge 1 ] && [ "${WORKER:-0}" -ge 1 ]; then
              echo "âœ… All services ready!" >> $GITHUB_STEP_SUMMARY
              echo "- Vote: https://vote-voting01-dev.agent.opsera.dev" >> $GITHUB_STEP_SUMMARY
              echo "- Result: https://result-voting01-dev.agent.opsera.dev" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### ðŸš€ Next Step: Promote to QA" >> $GITHUB_STEP_SUMMARY
              echo "To promote this build to QA, manually trigger the **Promote to QA** workflow:" >> $GITHUB_STEP_SUMMARY
              echo "1. Go to [Actions â†’ Promote to QA](${{ github.server_url }}/${{ github.repository }}/actions/workflows/ci-build-push-voting01-qa.yaml)" >> $GITHUB_STEP_SUMMARY
              echo "2. Click **Run workflow**" >> $GITHUB_STEP_SUMMARY
              echo "3. Enter image tag: \`${{ needs.build.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY
              echo "success=true" >> $GITHUB_OUTPUT
              exit 0
            fi
            sleep 15
          done
          echo "success=false" >> $GITHUB_OUTPUT

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # NOTIFICATIONS - Slack & Jira with Enhanced Formatting
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  notify-slack:
    name: "ðŸ“¢ Slack Notification"
    needs: [security-gitleaks, quality-sonarqube, build, deploy]
    if: |
      always() && (
        github.event.inputs.notify_on == 'always' ||
        (github.event.inputs.notify_on == 'failure' && contains(needs.*.result, 'failure')) ||
        (github.event.inputs.notify_on == 'success' && !contains(needs.*.result, 'failure')) ||
        (github.event.inputs.notify_on == '' && true)
      )
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    steps:
      - name: Check Slack Configuration
        id: check-slack
        run: |
          if [ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            echo "configured=true" >> $GITHUB_OUTPUT
          else
            echo "configured=false" >> $GITHUB_OUTPUT
            echo "âš ï¸ Slack webhook not configured - skipping notification" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Determine Status
        id: status
        if: steps.check-slack.outputs.configured == 'true'
        run: |
          # Check overall pipeline status
          DEPLOY_SUCCESS="${{ needs.deploy.outputs.success }}"
          SECURITY_RESULT="${{ needs.security-gitleaks.result }}"
          QUALITY_RESULT="${{ needs.quality-sonarqube.result }}"
          BUILD_RESULT="${{ needs.build.result }}"
          
          if [ "$DEPLOY_SUCCESS" = "true" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
            echo "emoji=âœ…" >> $GITHUB_OUTPUT
            echo "color=#36a64f" >> $GITHUB_OUTPUT
            echo "title=DEV Deployment Succeeded" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
            echo "emoji=âŒ" >> $GITHUB_OUTPUT
            echo "color=#dc3545" >> $GITHUB_OUTPUT
            echo "title=DEV Deployment Failed" >> $GITHUB_OUTPUT
          fi
          
          # Security status
          if [ "$SECURITY_RESULT" = "success" ]; then
            echo "security_icon=âœ…" >> $GITHUB_OUTPUT
          elif [ "$SECURITY_RESULT" = "skipped" ]; then
            echo "security_icon=â­ï¸" >> $GITHUB_OUTPUT
          else
            echo "security_icon=âš ï¸" >> $GITHUB_OUTPUT
          fi
          
          # Quality status
          QUALITY_GATE="${{ needs.quality-sonarqube.outputs.quality_gate_status }}"
          if [ "$QUALITY_GATE" = "OK" ]; then
            echo "quality_icon=âœ…" >> $GITHUB_OUTPUT
          elif [ "$QUALITY_RESULT" = "skipped" ]; then
            echo "quality_icon=â­ï¸" >> $GITHUB_OUTPUT
          else
            echo "quality_icon=âš ï¸" >> $GITHUB_OUTPUT
          fi

      - name: Send Slack Notification
        if: steps.check-slack.outputs.configured == 'true'
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "${{ steps.status.outputs.emoji }} ${{ steps.status.outputs.title }} - voting01",
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "${{ steps.status.outputs.emoji }} ${{ steps.status.outputs.title }}",
                    "emoji": true
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {"type": "mrkdwn", "text": "*Application:*\n`voting01`"},
                    {"type": "mrkdwn", "text": "*Environment:*\n`dev`"},
                    {"type": "mrkdwn", "text": "*Image Tag:*\n`${{ needs.build.outputs.image_tag }}`"},
                    {"type": "mrkdwn", "text": "*Triggered By:*\n${{ github.actor }}"}
                  ]
                },
                {
                  "type": "section",
                  "fields": [
                    {"type": "mrkdwn", "text": "*Security:* ${{ steps.status.outputs.security_icon }}"},
                    {"type": "mrkdwn", "text": "*Quality:* ${{ steps.status.outputs.quality_icon }}"},
                    {"type": "mrkdwn", "text": "*Build:* ${{ needs.build.result == 'success' && 'âœ…' || 'âŒ' }}"},
                    {"type": "mrkdwn", "text": "*Deploy:* ${{ needs.deploy.outputs.success == 'true' && 'âœ…' || 'âŒ' }}"}
                  ]
                },
                {
                  "type": "context",
                  "elements": [
                    {"type": "mrkdwn", "text": "Commit: `${{ github.sha }}` | Branch: `${{ github.ref_name }}`"}
                  ]
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {"type": "plain_text", "text": "View Workflow", "emoji": true},
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                    },
                    {
                      "type": "button",
                      "text": {"type": "plain_text", "text": "Promote to QA", "emoji": true},
                      "style": "primary",
                      "url": "${{ github.server_url }}/${{ github.repository }}/actions/workflows/ci-build-push-voting01-qa.yaml"
                    },
                    {
                      "type": "button",
                      "text": {"type": "plain_text", "text": "Vote App", "emoji": true},
                      "url": "https://vote-voting01-dev.agent.opsera.dev"
                    },
                    {
                      "type": "button",
                      "text": {"type": "plain_text", "text": "Result App", "emoji": true},
                      "url": "https://result-voting01-dev.agent.opsera.dev"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # JIRA SECURITY ISSUE - Create ticket when vulnerabilities found
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  notify-jira-security:
    name: "ðŸ”’ Jira Security Issue"
    needs: [build]
    if: always() && needs.build.outputs.has_security_findings == 'true'
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    continue-on-error: true
    steps:
      - name: Check Jira Configuration
        id: check-jira
        run: |
          CONFIGURED="true"
          MISSING=""

          if [ -z "${{ secrets.JIRA_API_TOKEN }}" ]; then
            CONFIGURED="false"
            MISSING="${MISSING} JIRA_API_TOKEN"
          fi
          if [ -z "${{ secrets.JIRA_BASE_URL }}" ]; then
            CONFIGURED="false"
            MISSING="${MISSING} JIRA_BASE_URL"
          fi

          echo "configured=${CONFIGURED}" >> $GITHUB_OUTPUT

          if [ "$CONFIGURED" = "false" ]; then
            echo "âš ï¸ Jira not configured - missing:${MISSING}" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Create Jira Security Issue
        if: steps.check-jira.outputs.configured == 'true'
        env:
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_PROJECT: ${{ secrets.JIRA_PROJECT }}
          JIRA_AUTH_TYPE: ${{ secrets.JIRA_AUTH_TYPE }}
        run: |
          TOTAL_CRIT="${{ needs.build.outputs.total_critical }}"
          TOTAL_HIGH="${{ needs.build.outputs.total_high }}"

          # Determine priority based on findings
          if [ "${TOTAL_CRIT:-0}" -gt 0 ]; then
            PRIORITY="High"
          else
            PRIORITY="Medium"
          fi

          # Set auth header based on auth type (api-key for mock Jira, basic for Jira Cloud)
          if [ "$JIRA_AUTH_TYPE" = "api-key" ]; then
            AUTH_HEADER="X-API-Key: ${JIRA_API_TOKEN}"
          else
            AUTH_HEADER="Authorization: Basic $(echo -n "${JIRA_EMAIL}:${JIRA_API_TOKEN}" | base64)"
          fi

          # Use configured project or default to TEST
          PROJECT_KEY="${JIRA_PROJECT:-TEST}"

          # Build description
          DESCRIPTION="Security scan detected vulnerabilities in container images for voting01-dev.

Vulnerability Summary:
- Vote: ${{ needs.build.outputs.vote_critical }} Critical, ${{ needs.build.outputs.vote_high }} High
- Result: ${{ needs.build.outputs.result_critical }} Critical, ${{ needs.build.outputs.result_high }} High
- Worker: ${{ needs.build.outputs.worker_critical }} Critical, ${{ needs.build.outputs.worker_high }} High
- TOTAL: ${TOTAL_CRIT} Critical, ${TOTAL_HIGH} High

Build Details:
- Image Tag: ${{ needs.build.outputs.image_tag }}
- Commit: ${{ github.sha }}
- Branch: ${{ github.ref_name }}
- Triggered by: ${{ github.actor }}

View full scan results: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # Create payload (API v2 format)
          PAYLOAD=$(jq -n \
            --arg project "$PROJECT_KEY" \
            --arg summary "[SECURITY] voting01-dev: ${TOTAL_CRIT} Critical, ${TOTAL_HIGH} High vulnerabilities" \
            --arg description "$DESCRIPTION" \
            --arg priority "$PRIORITY" \
            '{
              "fields": {
                "project": {"key": $project},
                "summary": $summary,
                "description": $description,
                "issuetype": {"name": "Task"},
                "priority": {"name": $priority}
              }
            }')

          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "${AUTH_HEADER}" \
            -H "Content-Type: application/json" \
            "${JIRA_BASE_URL}/rest/api/2/issue" \
            -d "$PAYLOAD")

          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | sed '$d')
          ISSUE_KEY=$(echo "$BODY" | jq -r '.key // "FAILED"')

          if [ "$ISSUE_KEY" != "FAILED" ] && [ "$ISSUE_KEY" != "null" ] && [ "$HTTP_CODE" = "201" ]; then
            echo "### ðŸ”’ Jira Security Issue Created" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Issue:** [$ISSUE_KEY](${JIRA_BASE_URL}/browse/${ISSUE_KEY})" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Service | Critical | High |" >> $GITHUB_STEP_SUMMARY
            echo "|---------|----------|------|" >> $GITHUB_STEP_SUMMARY
            echo "| Vote | ${{ needs.build.outputs.vote_critical }} | ${{ needs.build.outputs.vote_high }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Result | ${{ needs.build.outputs.result_critical }} | ${{ needs.build.outputs.result_high }} |" >> $GITHUB_STEP_SUMMARY
            echo "| Worker | ${{ needs.build.outputs.worker_critical }} | ${{ needs.build.outputs.worker_high }} |" >> $GITHUB_STEP_SUMMARY
            echo "| **Total** | **${TOTAL_CRIT}** | **${TOTAL_HIGH}** |" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Failed to create Jira security issue (HTTP $HTTP_CODE)" >> $GITHUB_STEP_SUMMARY
            echo "Response: $BODY" >> $GITHUB_STEP_SUMMARY
          fi

  notify-jira:
    name: "ðŸ“‹ Jira Issue"
    needs: [build, deploy]
    if: always() && needs.deploy.outputs.success == 'false'
    runs-on: ${{ github.event.inputs.runner == 'self-hosted' && fromJSON('["self-hosted", "linux", "opsera"]') || 'ubuntu-latest' }}
    continue-on-error: true
    steps:
      - name: Check Jira Configuration
        id: check-jira
        run: |
          CONFIGURED="true"
          MISSING=""

          if [ -z "${{ secrets.JIRA_API_TOKEN }}" ]; then
            CONFIGURED="false"
            MISSING="${MISSING} JIRA_API_TOKEN"
          fi
          if [ -z "${{ secrets.JIRA_BASE_URL }}" ]; then
            CONFIGURED="false"
            MISSING="${MISSING} JIRA_BASE_URL"
          fi

          echo "configured=${CONFIGURED}" >> $GITHUB_OUTPUT

          if [ "$CONFIGURED" = "false" ]; then
            echo "âš ï¸ Jira not configured - missing:${MISSING}" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Create Jira Issue
        if: steps.check-jira.outputs.configured == 'true'
        env:
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_PROJECT: ${{ secrets.JIRA_PROJECT }}
          JIRA_AUTH_TYPE: ${{ secrets.JIRA_AUTH_TYPE }}
        run: |
          # Set auth header based on auth type (api-key for mock Jira, basic for Jira Cloud)
          if [ "$JIRA_AUTH_TYPE" = "api-key" ]; then
            AUTH_HEADER="X-API-Key: ${JIRA_API_TOKEN}"
          else
            AUTH_HEADER="Authorization: Basic $(echo -n "${JIRA_EMAIL}:${JIRA_API_TOKEN}" | base64)"
          fi

          # Use configured project or default to TEST
          PROJECT_KEY="${JIRA_PROJECT:-TEST}"

          # Build description
          DESCRIPTION="Deployment failed for voting01-dev environment.

Details:
- Image Tag: ${{ needs.build.outputs.image_tag }}
- Commit: ${{ github.sha }}
- Branch: ${{ github.ref_name }}
- Triggered by: ${{ github.actor }}

Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # Create payload (API v2 format)
          PAYLOAD=$(jq -n \
            --arg project "$PROJECT_KEY" \
            --arg summary "[DEPLOY-FAIL] voting01-dev: Deployment Failed" \
            --arg description "$DESCRIPTION" \
            '{
              "fields": {
                "project": {"key": $project},
                "summary": $summary,
                "description": $description,
                "issuetype": {"name": "Task"},
                "priority": {"name": "High"}
              }
            }')

          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST \
            -H "${AUTH_HEADER}" \
            -H "Content-Type: application/json" \
            "${JIRA_BASE_URL}/rest/api/2/issue" \
            -d "$PAYLOAD")

          HTTP_CODE=$(echo "$RESPONSE" | tail -1)
          BODY=$(echo "$RESPONSE" | sed '$d')
          ISSUE_KEY=$(echo "$BODY" | jq -r '.key // "FAILED"')

          if [ "$ISSUE_KEY" != "FAILED" ] && [ "$ISSUE_KEY" != "null" ] && [ "$HTTP_CODE" = "201" ]; then
            echo "### ðŸ“‹ Jira Issue Created" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Issue:** [$ISSUE_KEY](${JIRA_BASE_URL}/browse/${ISSUE_KEY})" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|-------|" >> $GITHUB_STEP_SUMMARY
            echo "| Type | Deployment Failure |" >> $GITHUB_STEP_SUMMARY
            echo "| Environment | dev |" >> $GITHUB_STEP_SUMMARY
            echo "| Image Tag | ${{ needs.build.outputs.image_tag }} |" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Failed to create Jira issue (HTTP $HTTP_CODE)" >> $GITHUB_STEP_SUMMARY
            echo "Response: $BODY" >> $GITHUB_STEP_SUMMARY
          fi
