# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CI BUILD & PUSH - vote3 DEV Environment
# Generated by Opsera Code-to-Cloud Enterprise v0.905
#
# Strategy: Rolling Deployment
# Auto-Promote: DEV â†’ QA (enabled)
# Security: Gitleaks + Grype (warn mode)
# Quality: SonarQube (non-blocking)
# Notifications: Slack + Jira (on failure)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "CI Build & Push (vote3-dev)"

on:
  push:
    branches: [main]
    paths:
      - 'vote/**'
      - 'result/**'
      - 'worker/**'
      - '.opsera-vote3/**'
  workflow_dispatch:
    inputs:
      security_scan_mode:
        description: 'Security scan behavior'
        type: choice
        options: ['warn', 'fail', 'skip']
        default: 'warn'
      quality_gate_mode:
        description: 'Quality gate behavior'
        type: choice
        options: ['non-blocking', 'blocking', 'skip']
        default: 'non-blocking'
      auto_promote:
        description: 'Auto-promote to QA after success'
        type: boolean
        default: true
      image_tag:
        description: 'Use existing image tag (skip build)'
        type: string

env:
  APP_NAME: vote3
  ENVIRONMENT: dev
  AWS_REGION: us-west-2
  SPOKE_CLUSTER: opsera-usw2-np
  HUB_CLUSTER: argocd-usw2

permissions:
  contents: write
  id-token: write
  security-events: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # SECURITY SCANNING (Parallel with Build)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  security-gitleaks:
    name: "ðŸ”’ Gitleaks"
    runs-on: ubuntu-latest
    if: github.event.inputs.security_scan_mode != 'skip'
    continue-on-error: ${{ github.event.inputs.security_scan_mode != 'fail' }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # QUALITY GATES (Parallel with Build)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  quality-sonarqube:
    name: "ðŸ“Š SonarQube"
    runs-on: ubuntu-latest
    if: github.event.inputs.quality_gate_mode != 'skip'
    continue-on-error: ${{ github.event.inputs.quality_gate_mode != 'blocking' }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: SonarQube Scan
        if: env.SONAR_TOKEN != ''
        uses: sonarsource/sonarqube-scan-action@master
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # BUILD ALL SERVICES
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  build:
    name: "ðŸ—ï¸ Build All Services"
    runs-on: ubuntu-latest
    if: github.event.inputs.image_tag == ''
    outputs:
      image_tag: ${{ steps.tag.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      - name: Generate Image Tag
        id: tag
        run: |
          SHORT_SHA=$(git rev-parse --short HEAD)
          TIMESTAMP=$(date +%Y%m%d%H%M%S)
          IMAGE_TAG="${SHORT_SHA}-${TIMESTAMP}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "### ðŸ·ï¸ Image Tag: \`${IMAGE_TAG}\`" >> $GITHUB_STEP_SUMMARY

      - name: Build & Push Vote Service
        run: |
          ECR_REPO="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}-vote"

          docker build -f .opsera-vote3/Dockerfiles/Dockerfile.vote -t ${ECR_REPO}:${{ steps.tag.outputs.image_tag }} .
          docker push ${ECR_REPO}:${{ steps.tag.outputs.image_tag }}

          echo "âœ… Vote service pushed" >> $GITHUB_STEP_SUMMARY

      - name: Build & Push Result Service
        run: |
          ECR_REPO="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}-result"

          docker build -f .opsera-vote3/Dockerfiles/Dockerfile.result -t ${ECR_REPO}:${{ steps.tag.outputs.image_tag }} .
          docker push ${ECR_REPO}:${{ steps.tag.outputs.image_tag }}

          echo "âœ… Result service pushed" >> $GITHUB_STEP_SUMMARY

      - name: Build & Push Worker Service
        run: |
          ECR_REPO="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}-worker"

          docker build -f .opsera-vote3/Dockerfiles/Dockerfile.worker -t ${ECR_REPO}:${{ steps.tag.outputs.image_tag }} .
          docker push ${ECR_REPO}:${{ steps.tag.outputs.image_tag }}

          echo "âœ… Worker service pushed" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # CONTAINER SECURITY SCAN
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  security-grype:
    name: "ðŸ›¡ï¸ Grype Scan"
    needs: [build]
    if: always() && needs.build.result == 'success' && github.event.inputs.security_scan_mode != 'skip'
    runs-on: ubuntu-latest
    continue-on-error: ${{ github.event.inputs.security_scan_mode != 'fail' }}
    steps:
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to ECR
        run: |
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | \
            docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

      - name: Scan Vote Image
        uses: anchore/scan-action@v3
        with:
          image: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}-vote:${{ needs.build.outputs.image_tag }}
          fail-build: false
          severity-cutoff: high

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # UPDATE MANIFESTS & DEPLOY
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  deploy:
    name: "ðŸš€ Deploy to DEV"
    needs: [build, security-gitleaks, quality-sonarqube]
    if: always() && (needs.build.result == 'success' || github.event.inputs.image_tag != '')
    runs-on: ubuntu-latest
    outputs:
      deploy_success: ${{ steps.verify.outputs.success }}
      image_tag: ${{ steps.get-tag.outputs.image_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Get Image Tag
        id: get-tag
        run: |
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            echo "image_tag=${{ github.event.inputs.image_tag }}" >> $GITHUB_OUTPUT
          else
            echo "image_tag=${{ needs.build.outputs.image_tag }}" >> $GITHUB_OUTPUT
          fi

      - name: Update Kustomization
        run: |
          IMAGE_TAG="${{ steps.get-tag.outputs.image_tag }}"
          ECR_REGISTRY="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"

          cd .opsera-vote3/k8s/overlays/${{ env.ENVIRONMENT }}

          # Update all image tags
          sed -i "s|newTag:.*|newTag: ${IMAGE_TAG}|g" kustomization.yaml

      - name: Commit & Push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add .opsera-vote3/k8s/overlays/${{ env.ENVIRONMENT }}/

          if git diff --cached --quiet; then
            echo "No changes to commit"
          else
            git commit -m "deploy(vote3-${{ env.ENVIRONMENT }}): Update to ${{ steps.get-tag.outputs.image_tag }} [skip ci]"
            git pull --rebase origin main
            git push origin main
          fi

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Trigger ArgoCD Sync
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

          APP_NAME="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"

          kubectl annotate application "$APP_NAME" -n argocd \
            argocd.argoproj.io/refresh=hard --overwrite

          echo "âœ… ArgoCD sync triggered"

      - name: Wait for Deployment
        id: verify
        run: |
          aws eks update-kubeconfig --name ${{ env.SPOKE_CLUSTER }} --region ${{ env.AWS_REGION }}

          NAMESPACE="${{ env.APP_NAME }}-${{ env.ENVIRONMENT }}"
          TIMEOUT=300
          ELAPSED=0

          while [ $ELAPSED -lt $TIMEOUT ]; do
            VOTE_READY=$(kubectl get deployment vote -n $NAMESPACE -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")
            RESULT_READY=$(kubectl get deployment result -n $NAMESPACE -o jsonpath='{.status.readyReplicas}' 2>/dev/null || echo "0")

            echo "Vote: ${VOTE_READY:-0}/2, Result: ${RESULT_READY:-0}/2"

            if [ "${VOTE_READY:-0}" -ge 1 ] && [ "${RESULT_READY:-0}" -ge 1 ]; then
              echo "âœ… Deployment successful"
              echo "success=true" >> $GITHUB_OUTPUT
              exit 0
            fi

            sleep 15
            ELAPSED=$((ELAPSED + 15))
          done

          echo "âš ï¸ Deployment timeout"
          echo "success=false" >> $GITHUB_OUTPUT

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # AUTO-PROMOTE TO QA
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  auto-promote:
    name: "â© Auto-Promote to QA"
    needs: [deploy]
    if: |
      always() &&
      needs.deploy.outputs.deploy_success == 'true' &&
      (github.event.inputs.auto_promote == 'true' || github.event.inputs.auto_promote == '')
    runs-on: ubuntu-latest
    steps:
      - name: Trigger QA Deployment
        run: |
          gh workflow run "ci-build-push-vote3-qa.yaml" \
            --repo ${{ github.repository }} \
            -f image_tag=${{ needs.deploy.outputs.image_tag }} \
            -f auto_promote=false
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}

      - name: Summary
        run: |
          echo "### â© Auto-Promotion Triggered" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **From:** DEV" >> $GITHUB_STEP_SUMMARY
          echo "- **To:** QA" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag:** \`${{ needs.deploy.outputs.image_tag }}\`" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # NOTIFICATIONS
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  notify-slack:
    name: "ðŸ“¢ Slack"
    needs: [deploy]
    if: always() && (failure() || needs.deploy.outputs.deploy_success == 'false')
    runs-on: ubuntu-latest
    steps:
      - name: Send Slack Notification
        if: env.SLACK_WEBHOOK_URL != ''
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "blocks": [
                {
                  "type": "header",
                  "text": {
                    "type": "plain_text",
                    "text": "âŒ Deployment Failed: vote3-dev"
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {"type": "mrkdwn", "text": "*App:*\nvote3"},
                    {"type": "mrkdwn", "text": "*Environment:*\ndev"},
                    {"type": "mrkdwn", "text": "*Commit:*\n${{ github.sha }}"},
                    {"type": "mrkdwn", "text": "*Actor:*\n${{ github.actor }}"}
                  ]
                },
                {
                  "type": "actions",
                  "elements": [{
                    "type": "button",
                    "text": {"type": "plain_text", "text": "View Workflow"},
                    "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  notify-jira:
    name: "ðŸ“‹ Jira"
    needs: [deploy]
    if: always() && (failure() || needs.deploy.outputs.deploy_success == 'false')
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - name: Extract Jira Issue
        id: jira
        run: |
          COMMIT_MSG="${{ github.event.head_commit.message }}"
          ISSUE_KEY=$(echo "$COMMIT_MSG" | grep -oP '[A-Z]+-[0-9]+' | head -1 || echo "")
          echo "issue_key=${ISSUE_KEY}" >> $GITHUB_OUTPUT

      - name: Add Comment to Jira
        if: steps.jira.outputs.issue_key != '' && env.JIRA_API_TOKEN != ''
        run: |
          AUTH=$(echo -n "${{ secrets.JIRA_EMAIL }}:${{ secrets.JIRA_API_TOKEN }}" | base64)

          curl -X POST \
            -H "Authorization: Basic $AUTH" \
            -H "Content-Type: application/json" \
            "${{ secrets.JIRA_BASE_URL }}/rest/api/3/issue/${{ steps.jira.outputs.issue_key }}/comment" \
            -d '{
              "body": {
                "type": "doc",
                "version": 1,
                "content": [{
                  "type": "paragraph",
                  "content": [
                    {"type": "text", "text": "Deployment to dev failed. "},
                    {"type": "text", "marks": [{"type": "link", "attrs": {"href": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"}}], "text": "View Workflow"}
                  ]
                }]
              }
            }'
        env:
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
