# â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
# â•‘  LIST & CLEANUP ARGOCD APPS - Hub-Spoke inventory and cleanup                    â•‘
# â•‘  Generated by Opsera Code-to-Cloud v0.6                                          â•‘
# â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "95-List & Cleanup ArgoCD Apps"

on:
  workflow_dispatch:
    inputs:
      action:
        description: "Action to perform"
        required: true
        default: "list"
        type: choice
        options:
          - list                    # List all apps (safe, read-only)
          - delete-single           # Delete a specific app
          - delete-by-prefix        # Delete all apps matching prefix
          - delete-high-pod-apps    # Delete apps with >5 pods (requires confirmation)
          - cleanup-orphaned-ns     # Clean up namespaces without ArgoCD apps
      app_name:
        description: "App name (for delete-single)"
        required: false
        type: string
      app_prefix:
        description: "App prefix (for delete-by-prefix, e.g., 'voting2' or 'test-')"
        required: false
        type: string
      cleanup_spoke:
        description: "Also cleanup spoke cluster resources?"
        required: false
        default: "yes"
        type: choice
        options:
          - "yes"
          - "no"
      dry_run:
        description: "Dry run (show what would be deleted, don't actually delete)"
        required: false
        default: "true"
        type: choice
        options:
          - "true"
          - "false"
      confirm_high_pod_delete:
        description: "Type 'DELETE-HIGH-POD-APPS' to confirm deletion of apps with >5 pods"
        required: false
        type: string

env:
  AWS_REGION: us-west-2
  HUB_CLUSTER: argocd-usw2
  # Spoke clusters in us-west-2
  SPOKE_NP: opsera-usw2-np
  SPOKE_PROD: opsera-usw2-prod

permissions:
  id-token: write
  contents: read

jobs:
  list-applications:
    name: "ðŸ“‹ List All ArgoCD Applications"
    runs-on: ubuntu-latest
    outputs:
      apps_json: ${{ steps.list.outputs.apps_json }}
      spoke_clusters: ${{ steps.list.outputs.spoke_clusters }}
      high_pod_apps: ${{ steps.list.outputs.high_pod_apps }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          # Use the same role that bootstrap uses for hub cluster access
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/voting2-dev-github-actions
          role-session-name: argocd-list-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Connect to Hub Cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}
          echo "âœ… Connected to Hub Cluster: ${{ env.HUB_CLUSTER }}"

      - name: List All Applications
        id: list
        run: |
          echo "# ðŸ“‹ ArgoCD Applications Inventory" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Hub Cluster**: \`${{ env.HUB_CLUSTER }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Region**: \`${{ env.AWS_REGION }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Time**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Get all applications from hub
          APPS_JSON=$(kubectl get applications -n argocd -o json)
          TOTAL=$(echo "$APPS_JSON" | jq '.items | length')

          # Extract unique destination clusters
          CLUSTERS=$(echo "$APPS_JSON" | jq -r '[.items[].spec.destination.name // .items[].spec.destination.server] | unique | .[]')

          # Build app list with pod counts using jq (avoid shell loops)
          echo "Collecting pod counts from spoke clusters..."
          > /tmp/app_pods.txt
          > /tmp/ns_pod_counts.json
          echo '{}' > /tmp/ns_pod_counts.json

          # Get unique namespaces per cluster for pod counting
          for cluster in $CLUSTERS; do
            # Determine spoke cluster name
            if [[ "$cluster" == *"np"* ]] || [[ "$cluster" == *"non-prod"* ]]; then
              SPOKE="${{ env.SPOKE_NP }}"
            elif [[ "$cluster" == *"prod"* ]]; then
              SPOKE="${{ env.SPOKE_PROD }}"
            else
              SPOKE="$cluster"
            fi

            # Try to connect to spoke cluster and get pod counts
            aws eks update-kubeconfig --name "$SPOKE" --region ${{ env.AWS_REGION }} 2>/dev/null || true
            echo "Attempting to access spoke: $SPOKE"

            # Test if we can actually access the spoke cluster
            if kubectl get namespaces --request-timeout=10s >/dev/null 2>&1; then
              echo "âœ… Connected to spoke: $SPOKE"
              echo "Looking for apps targeting cluster: $cluster"

              # Get namespace pod counts as JSON object
              echo "Getting pod counts from spoke..."
              kubectl get pods --all-namespaces -o json 2>/dev/null | jq '
                [.items[] | .metadata.namespace] | group_by(.) |
                map({key: .[0], value: length}) | from_entries
              ' > /tmp/ns_pod_counts.json 2>/dev/null || echo '{}' > /tmp/ns_pod_counts.json

              # Debug: show pod counts
              echo "Pod counts by namespace:"
              cat /tmp/ns_pod_counts.json

              # Use jq to join apps with pod counts
              echo "$APPS_JSON" | jq -r --arg c "$cluster" --slurpfile pods /tmp/ns_pod_counts.json '
                .items[] |
                select(.spec.destination.name == $c or .spec.destination.server == $c) |
                {
                  name: .metadata.name,
                  ns: .spec.destination.namespace,
                  dest: (.spec.destination.name // "in-cluster"),
                  sync: (.status.sync.status // "Unknown"),
                  health: (.status.health.status // "Unknown"),
                  path: (.spec.source.path // "N/A")
                } |
                "\($pods[0][.ns] // 0)|\(.name)|\(.ns)|\(.dest)|\(.sync)|\(.health)|\(.path)"
              ' >> /tmp/app_pods.txt
            else
              echo "âš ï¸ Cannot access spoke cluster: $SPOKE"
              echo "   (IAM role needs to be added to spoke cluster's aws-auth ConfigMap)"
              echo "   Pod counts will show as '?' for apps on this cluster"
              # Add apps with unknown pod count
              echo "$APPS_JSON" | jq -r --arg c "$cluster" '
                .items[] |
                select(.spec.destination.name == $c or .spec.destination.server == $c) |
                "?|\(.metadata.name)|\(.spec.destination.namespace)|\(.spec.destination.name // "in-cluster")|\(.status.sync.status // "Unknown")|\(.status.health.status // "Unknown")|\(.spec.source.path // "N/A")"
              ' >> /tmp/app_pods.txt
            fi
          done

          # Reconnect to hub for remaining operations
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

          # Count apps by pod threshold
          HIGH_POD_COUNT=$(awk -F'|' '$1 != "?" && $1 > 5 {count++} END {print count+0}' /tmp/app_pods.txt)
          TOTAL_PODS=$(awk -F'|' '$1 != "?" {sum+=$1} END {print sum+0}' /tmp/app_pods.txt)

          echo "## ðŸ“Š Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **Total Applications** | $TOTAL |" >> $GITHUB_STEP_SUMMARY
          echo "| **Total Pods** | $TOTAL_PODS |" >> $GITHUB_STEP_SUMMARY
          echo "| **Apps with >5 pods** | âš ï¸ $HIGH_POD_COUNT |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          echo "**Target Clusters (Spokes)**:" >> $GITHUB_STEP_SUMMARY
          for cluster in $CLUSTERS; do
            echo "- \`$cluster\`" >> $GITHUB_STEP_SUMMARY
          done
          echo "" >> $GITHUB_STEP_SUMMARY

          # Hub-Spoke Architecture Diagram
          echo "## ðŸ—ï¸ Hub-Spoke Architecture" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”" >> $GITHUB_STEP_SUMMARY
          echo "â”‚                    HUB CLUSTER                               â”‚" >> $GITHUB_STEP_SUMMARY
          echo "â”‚                  ${{ env.HUB_CLUSTER }}                              â”‚" >> $GITHUB_STEP_SUMMARY
          echo "â”‚                    (ArgoCD)                                  â”‚" >> $GITHUB_STEP_SUMMARY
          echo "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜" >> $GITHUB_STEP_SUMMARY
          echo "                          â”‚" >> $GITHUB_STEP_SUMMARY
          echo "          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”" >> $GITHUB_STEP_SUMMARY
          echo "          â”‚               â”‚               â”‚" >> $GITHUB_STEP_SUMMARY
          echo "          â–¼               â–¼               â–¼" >> $GITHUB_STEP_SUMMARY
          echo "   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”" >> $GITHUB_STEP_SUMMARY
          echo "   â”‚  SPOKE: NP  â”‚ â”‚ SPOKE: PROD â”‚ â”‚ SPOKE: ...  â”‚" >> $GITHUB_STEP_SUMMARY
          echo "   â”‚ (Workloads) â”‚ â”‚ (Workloads) â”‚ â”‚ (Workloads) â”‚" >> $GITHUB_STEP_SUMMARY
          echo "   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Detailed Application Table - SORTED BY POD COUNT (descending)
          echo "## ðŸ“ Application Details (Sorted by Pod Count)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Pods | App Name | Namespace | Dest Cluster | Sync | Health | Action |" >> $GITHUB_STEP_SUMMARY
          echo "|------|----------|-----------|--------------|------|--------|--------|" >> $GITHUB_STEP_SUMMARY

          # Sort by pod count descending (numeric sort)
          sort -t'|' -k1 -rn /tmp/app_pods.txt | while IFS='|' read PODS NAME NS DEST SYNC HEALTH PATH; do
            # Status icons
            SYNC_ICON="âœ…"; [ "$SYNC" != "Synced" ] && SYNC_ICON="âš ï¸"
            HEALTH_ICON="âœ…"; [ "$HEALTH" != "Healthy" ] && HEALTH_ICON="âš ï¸"; [ "$HEALTH" == "Degraded" ] && HEALTH_ICON="âŒ"

            # Mark for deletion if >5 pods
            if [ "$PODS" != "?" ] && [ "$PODS" -gt 5 ]; then
              ACTION="ðŸ—‘ï¸ **DELETE**"
              POD_DISPLAY="**$PODS** âš ï¸"
            else
              ACTION="-"
              POD_DISPLAY="$PODS"
            fi

            echo "| $POD_DISPLAY | \`$NAME\` | \`$NS\` | \`$DEST\` | $SYNC_ICON $SYNC | $HEALTH_ICON $HEALTH | $ACTION |" >> $GITHUB_STEP_SUMMARY
          done

          echo "" >> $GITHUB_STEP_SUMMARY

          # High Pod Apps Section (>5 pods)
          if [ "$HIGH_POD_COUNT" -gt 0 ]; then
            echo "## âš ï¸ Apps Marked for Deletion (>5 pods)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The following applications have more than 5 pods and are marked for deletion:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| App Name | Pods | Namespace | Cluster |" >> $GITHUB_STEP_SUMMARY
            echo "|----------|------|-----------|---------|" >> $GITHUB_STEP_SUMMARY

            awk -F'|' '$1 != "?" && $1 > 5' /tmp/app_pods.txt | sort -t'|' -k1 -rn | while IFS='|' read PODS NAME NS DEST SYNC HEALTH PATH; do
              echo "| \`$NAME\` | **$PODS** | \`$NS\` | \`$DEST\` |" >> $GITHUB_STEP_SUMMARY
            done

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**To delete these apps**, re-run this workflow with:" >> $GITHUB_STEP_SUMMARY
            echo "- action: \`delete-high-pod-apps\`" >> $GITHUB_STEP_SUMMARY
            echo "- confirm_high_pod_delete: \`DELETE-HIGH-POD-APPS\`" >> $GITHUB_STEP_SUMMARY
            echo "- dry_run: \`false\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Save high-pod apps list for downstream job
            HIGH_POD_APPS=$(awk -F'|' '$1 != "?" && $1 > 5 {print $2}' /tmp/app_pods.txt | tr '\n' ',' | sed 's/,$//')
            echo "high_pod_apps=$HIGH_POD_APPS" >> $GITHUB_OUTPUT
          else
            echo "## âœ… No Apps Exceed Pod Threshold" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "All applications have 5 or fewer pods." >> $GITHUB_STEP_SUMMARY
            echo "high_pod_apps=" >> $GITHUB_OUTPUT
          fi

          echo "" >> $GITHUB_STEP_SUMMARY

          # Group by destination cluster
          echo "## ðŸŽ¯ Apps by Destination Cluster" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          for cluster in $CLUSTERS; do
            CLUSTER_APPS=$(echo "$APPS_JSON" | jq -r --arg c "$cluster" '[.items[] | select(.spec.destination.name == $c or .spec.destination.server == $c)] | length')
            echo "### Cluster: \`$cluster\` ($CLUSTER_APPS apps)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "$APPS_JSON" | jq -r --arg c "$cluster" '
              .items[] |
              select(.spec.destination.name == $c or .spec.destination.server == $c) |
              "- \(.metadata.name) â†’ \(.spec.destination.namespace)"
            ' >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          done

          # Save for downstream jobs
          echo "$APPS_JSON" | jq -c '.' > /tmp/apps.json
          echo "apps_json=$(cat /tmp/apps.json | base64 -w0)" >> $GITHUB_OUTPUT
          echo "spoke_clusters=$CLUSTERS" >> $GITHUB_OUTPUT

      - name: List Registered Clusters
        run: |
          echo "## ðŸ”— Registered Clusters in ArgoCD" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          kubectl get secrets -n argocd -l argocd.argoproj.io/secret-type=cluster -o custom-columns="NAME:.metadata.name,SERVER:.data.server" 2>/dev/null | while read line; do
            echo "$line" >> $GITHUB_STEP_SUMMARY
          done || echo "No external clusters registered" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Also show cluster secrets with decoded server URLs
          echo "### Cluster Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          kubectl get secrets -n argocd -l argocd.argoproj.io/secret-type=cluster -o json 2>/dev/null | jq -r '
            .items[] |
            "- **\(.metadata.name)**: \(.data.server | @base64d)"
          ' >> $GITHUB_STEP_SUMMARY || echo "No clusters to show" >> $GITHUB_STEP_SUMMARY

  delete-single:
    name: "ðŸ—‘ï¸ Delete Single Application"
    runs-on: ubuntu-latest
    needs: [list-applications]
    if: github.event.inputs.action == 'delete-single' && github.event.inputs.app_name != ''

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/voting2-dev-github-actions
          role-session-name: argocd-delete-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Delete Application
        run: |
          APP_NAME="${{ github.event.inputs.app_name }}"
          DRY_RUN="${{ github.event.inputs.dry_run }}"

          echo "# ðŸ—‘ï¸ Delete Application: \`$APP_NAME\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Dry Run**: $DRY_RUN" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Connect to hub
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

          # Check if app exists
          if ! kubectl get application "$APP_NAME" -n argocd &>/dev/null; then
            echo "âŒ Application \`$APP_NAME\` not found" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

          # Get app details before deletion
          APP_JSON=$(kubectl get application "$APP_NAME" -n argocd -o json)
          DEST_NS=$(echo "$APP_JSON" | jq -r '.spec.destination.namespace')
          DEST_CLUSTER=$(echo "$APP_JSON" | jq -r '.spec.destination.name // "in-cluster"')

          echo "## Application Details" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Property | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Namespace | \`$DEST_NS\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Target Cluster | \`$DEST_CLUSTER\` |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "$DRY_RUN" == "true" ]; then
            echo "## ðŸ” Dry Run - Would Delete:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "1. ArgoCD Application \`$APP_NAME\` from hub cluster" >> $GITHUB_STEP_SUMMARY
            if [ "${{ github.event.inputs.cleanup_spoke }}" == "yes" ]; then
              echo "2. Namespace \`$DEST_NS\` from spoke cluster \`$DEST_CLUSTER\`" >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**To actually delete, re-run with dry_run=false**" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ðŸ—‘ï¸ Deleting..." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            # Delete ArgoCD application (cascade deletes resources)
            kubectl delete application "$APP_NAME" -n argocd --cascade=foreground
            echo "âœ… Deleted ArgoCD Application \`$APP_NAME\`" >> $GITHUB_STEP_SUMMARY

            # Optionally cleanup spoke namespace
            if [ "${{ github.event.inputs.cleanup_spoke }}" == "yes" ] && [ "$DEST_CLUSTER" != "in-cluster" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### Cleaning up Spoke Cluster: \`$DEST_CLUSTER\`" >> $GITHUB_STEP_SUMMARY

              # Try to connect to spoke cluster
              if [[ "$DEST_CLUSTER" == *"np"* ]]; then
                SPOKE="${{ env.SPOKE_NP }}"
              elif [[ "$DEST_CLUSTER" == *"prod"* ]]; then
                SPOKE="${{ env.SPOKE_PROD }}"
              else
                SPOKE="$DEST_CLUSTER"
              fi

              if aws eks update-kubeconfig --name "$SPOKE" --region ${{ env.AWS_REGION }} 2>/dev/null; then
                if kubectl get namespace "$DEST_NS" &>/dev/null; then
                  kubectl delete namespace "$DEST_NS" --timeout=120s || true
                  echo "âœ… Deleted namespace \`$DEST_NS\` from spoke" >> $GITHUB_STEP_SUMMARY
                else
                  echo "â„¹ï¸ Namespace \`$DEST_NS\` already gone from spoke" >> $GITHUB_STEP_SUMMARY
                fi
              else
                echo "âš ï¸ Could not connect to spoke cluster \`$SPOKE\`" >> $GITHUB_STEP_SUMMARY
              fi
            fi

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## âœ… Deletion Complete" >> $GITHUB_STEP_SUMMARY
          fi

  delete-by-prefix:
    name: "ðŸ—‘ï¸ Delete Apps by Prefix"
    runs-on: ubuntu-latest
    needs: [list-applications]
    if: github.event.inputs.action == 'delete-by-prefix' && github.event.inputs.app_prefix != ''

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/voting2-dev-github-actions
          role-session-name: argocd-delete-prefix-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Delete Apps by Prefix
        run: |
          PREFIX="${{ github.event.inputs.app_prefix }}"
          DRY_RUN="${{ github.event.inputs.dry_run }}"

          echo "# ðŸ—‘ï¸ Delete Apps with Prefix: \`$PREFIX\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Dry Run**: $DRY_RUN" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Connect to hub
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

          # Find matching apps
          MATCHING_APPS=$(kubectl get applications -n argocd -o json | jq -r --arg p "$PREFIX" '.items[] | select(.metadata.name | startswith($p)) | .metadata.name')
          MATCH_COUNT=$(echo "$MATCHING_APPS" | grep -c . || echo "0")

          echo "## ðŸ” Matching Applications: $MATCH_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "$MATCH_COUNT" -eq 0 ]; then
            echo "âŒ No applications found matching prefix \`$PREFIX\`" >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # List matching apps with details
          echo "| App Name | Namespace | Cluster |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-----------|---------|" >> $GITHUB_STEP_SUMMARY

          for app in $MATCHING_APPS; do
            APP_JSON=$(kubectl get application "$app" -n argocd -o json)
            NS=$(echo "$APP_JSON" | jq -r '.spec.destination.namespace')
            CLUSTER=$(echo "$APP_JSON" | jq -r '.spec.destination.name // "in-cluster"')
            echo "| \`$app\` | \`$NS\` | \`$CLUSTER\` |" >> $GITHUB_STEP_SUMMARY
          done
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "$DRY_RUN" == "true" ]; then
            echo "## ðŸ” Dry Run - Would Delete $MATCH_COUNT Applications" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**To actually delete, re-run with dry_run=false**" >> $GITHUB_STEP_SUMMARY
          else
            echo "## ðŸ—‘ï¸ Deleting $MATCH_COUNT Applications..." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            NAMESPACES_TO_DELETE=""

            for app in $MATCHING_APPS; do
              # Get namespace before deletion
              APP_JSON=$(kubectl get application "$app" -n argocd -o json 2>/dev/null || echo "{}")
              NS=$(echo "$APP_JSON" | jq -r '.spec.destination.namespace // ""')
              CLUSTER=$(echo "$APP_JSON" | jq -r '.spec.destination.name // "in-cluster"')

              if [ -n "$NS" ] && [ "$NS" != "null" ]; then
                NAMESPACES_TO_DELETE="$NAMESPACES_TO_DELETE $CLUSTER:$NS"
              fi

              # Delete application
              kubectl delete application "$app" -n argocd --cascade=foreground --timeout=120s || true
              echo "âœ… Deleted \`$app\`" >> $GITHUB_STEP_SUMMARY
            done

            # Cleanup spoke namespaces if requested
            if [ "${{ github.event.inputs.cleanup_spoke }}" == "yes" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "### ðŸ§¹ Cleaning Spoke Cluster Namespaces" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY

              # Dedupe namespaces
              UNIQUE_NS=$(echo "$NAMESPACES_TO_DELETE" | tr ' ' '\n' | sort -u)

              for entry in $UNIQUE_NS; do
                CLUSTER=$(echo "$entry" | cut -d: -f1)
                NS=$(echo "$entry" | cut -d: -f2)

                if [ -z "$NS" ] || [ "$NS" == "null" ]; then
                  continue
                fi

                # Determine spoke cluster name
                if [[ "$CLUSTER" == *"np"* ]] || [[ "$CLUSTER" == *"non-prod"* ]]; then
                  SPOKE="${{ env.SPOKE_NP }}"
                elif [[ "$CLUSTER" == *"prod"* ]]; then
                  SPOKE="${{ env.SPOKE_PROD }}"
                else
                  SPOKE="$CLUSTER"
                fi

                if aws eks update-kubeconfig --name "$SPOKE" --region ${{ env.AWS_REGION }} 2>/dev/null; then
                  if kubectl get namespace "$NS" &>/dev/null; then
                    kubectl delete namespace "$NS" --timeout=120s || true
                    echo "âœ… Deleted namespace \`$NS\` from \`$SPOKE\`" >> $GITHUB_STEP_SUMMARY
                  fi
                fi
              done
            fi

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## âœ… Bulk Deletion Complete" >> $GITHUB_STEP_SUMMARY
          fi

  delete-high-pod-apps:
    name: "ðŸ—‘ï¸ Delete High-Pod Apps (>5 pods)"
    runs-on: ubuntu-latest
    needs: [list-applications]
    if: github.event.inputs.action == 'delete-high-pod-apps'

    steps:
      - name: Validate Confirmation
        run: |
          CONFIRMATION="${{ github.event.inputs.confirm_high_pod_delete }}"
          if [ "$CONFIRMATION" != "DELETE-HIGH-POD-APPS" ]; then
            echo "# âŒ Confirmation Required" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "To delete apps with >5 pods, you must enter the confirmation code:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Required**: \`DELETE-HIGH-POD-APPS\`" >> $GITHUB_STEP_SUMMARY
            echo "**Received**: \`$CONFIRMATION\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Re-run this workflow with the correct confirmation code." >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          echo "âœ… Confirmation validated"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/voting2-dev-github-actions
          role-session-name: argocd-delete-high-pod-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Delete High-Pod Applications
        run: |
          DRY_RUN="${{ github.event.inputs.dry_run }}"
          HIGH_POD_APPS="${{ needs.list-applications.outputs.high_pod_apps }}"

          echo "# ðŸ—‘ï¸ Delete High-Pod Applications (>5 pods)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Dry Run**: $DRY_RUN" >> $GITHUB_STEP_SUMMARY
          echo "**Confirmation**: âœ… Validated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Connect to hub
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

          if [ -z "$HIGH_POD_APPS" ]; then
            echo "## âœ… No High-Pod Apps Found" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "There are no applications with more than 5 pods to delete." >> $GITHUB_STEP_SUMMARY
            exit 0
          fi

          # Convert comma-separated list to space-separated
          APPS_LIST=$(echo "$HIGH_POD_APPS" | tr ',' ' ')
          APP_COUNT=$(echo "$APPS_LIST" | wc -w | tr -d ' ')

          echo "## ðŸ“‹ Applications to Delete: $APP_COUNT" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| App Name | Namespace | Cluster | Pods | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-----------|---------|------|--------|" >> $GITHUB_STEP_SUMMARY

          NAMESPACES_TO_DELETE=""

          for app in $APPS_LIST; do
            # Get app details
            APP_JSON=$(kubectl get application "$app" -n argocd -o json 2>/dev/null || echo "{}")
            if [ "$APP_JSON" == "{}" ]; then
              echo "| \`$app\` | - | - | - | âš ï¸ Not found |" >> $GITHUB_STEP_SUMMARY
              continue
            fi

            NS=$(echo "$APP_JSON" | jq -r '.spec.destination.namespace')
            CLUSTER=$(echo "$APP_JSON" | jq -r '.spec.destination.name // "in-cluster"')

            # Get pod count from spoke
            if [[ "$CLUSTER" == *"np"* ]] || [[ "$CLUSTER" == *"non-prod"* ]]; then
              SPOKE="${{ env.SPOKE_NP }}"
            elif [[ "$CLUSTER" == *"prod"* ]]; then
              SPOKE="${{ env.SPOKE_PROD }}"
            else
              SPOKE="$CLUSTER"
            fi

            POD_COUNT="?"
            if aws eks update-kubeconfig --name "$SPOKE" --region ${{ env.AWS_REGION }} 2>/dev/null; then
              POD_COUNT=$(kubectl get pods -n "$NS" --no-headers 2>/dev/null | wc -l | tr -d ' ' || echo "?")
            fi

            # Reconnect to hub
            aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

            if [ "$DRY_RUN" == "true" ]; then
              echo "| \`$app\` | \`$NS\` | \`$CLUSTER\` | $POD_COUNT | ðŸ” Would delete |" >> $GITHUB_STEP_SUMMARY
            else
              # Save namespace for cleanup
              if [ -n "$NS" ] && [ "$NS" != "null" ]; then
                NAMESPACES_TO_DELETE="$NAMESPACES_TO_DELETE $CLUSTER:$NS"
              fi

              # Delete application
              kubectl delete application "$app" -n argocd --cascade=foreground --timeout=120s || true
              echo "| \`$app\` | \`$NS\` | \`$CLUSTER\` | $POD_COUNT | âœ… Deleted |" >> $GITHUB_STEP_SUMMARY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "$DRY_RUN" == "true" ]; then
            echo "## ðŸ” Dry Run Complete" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**To actually delete these apps, re-run with dry_run=false**" >> $GITHUB_STEP_SUMMARY
          else
            # Cleanup spoke namespaces if requested
            if [ "${{ github.event.inputs.cleanup_spoke }}" == "yes" ] && [ -n "$NAMESPACES_TO_DELETE" ]; then
              echo "### ðŸ§¹ Cleaning Spoke Cluster Namespaces" >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY

              UNIQUE_NS=$(echo "$NAMESPACES_TO_DELETE" | tr ' ' '\n' | sort -u)

              for entry in $UNIQUE_NS; do
                CLUSTER=$(echo "$entry" | cut -d: -f1)
                NS=$(echo "$entry" | cut -d: -f2)

                if [ -z "$NS" ] || [ "$NS" == "null" ]; then
                  continue
                fi

                if [[ "$CLUSTER" == *"np"* ]] || [[ "$CLUSTER" == *"non-prod"* ]]; then
                  SPOKE="${{ env.SPOKE_NP }}"
                elif [[ "$CLUSTER" == *"prod"* ]]; then
                  SPOKE="${{ env.SPOKE_PROD }}"
                else
                  SPOKE="$CLUSTER"
                fi

                if aws eks update-kubeconfig --name "$SPOKE" --region ${{ env.AWS_REGION }} 2>/dev/null; then
                  if kubectl get namespace "$NS" &>/dev/null; then
                    kubectl delete namespace "$NS" --timeout=120s || true
                    echo "âœ… Deleted namespace \`$NS\` from \`$SPOKE\`" >> $GITHUB_STEP_SUMMARY
                  fi
                fi
              done
            fi

            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## âœ… High-Pod Apps Deletion Complete" >> $GITHUB_STEP_SUMMARY
          fi

  cleanup-orphaned:
    name: "ðŸ§¹ Cleanup Orphaned Namespaces"
    runs-on: ubuntu-latest
    needs: [list-applications]
    if: github.event.inputs.action == 'cleanup-orphaned-ns'

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/voting2-dev-github-actions
          role-session-name: argocd-cleanup-${{ github.run_id }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Find and Cleanup Orphaned Namespaces
        run: |
          DRY_RUN="${{ github.event.inputs.dry_run }}"

          echo "# ðŸ§¹ Orphaned Namespace Cleanup" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Dry Run**: $DRY_RUN" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Connect to hub and get all managed namespaces
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}
          MANAGED_NS=$(kubectl get applications -n argocd -o json | jq -r '.items[].spec.destination.namespace' | sort -u)

          echo "## ArgoCD Managed Namespaces" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          for ns in $MANAGED_NS; do
            echo "- \`$ns\`" >> $GITHUB_STEP_SUMMARY
          done
          echo "" >> $GITHUB_STEP_SUMMARY

          # Check each spoke cluster
          for SPOKE in "${{ env.SPOKE_NP }}" "${{ env.SPOKE_PROD }}"; do
            echo "## Checking Spoke: \`$SPOKE\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY

            if ! aws eks update-kubeconfig --name "$SPOKE" --region ${{ env.AWS_REGION }} 2>/dev/null; then
              echo "âš ï¸ Could not connect to \`$SPOKE\`" >> $GITHUB_STEP_SUMMARY
              continue
            fi

            # Get all namespaces (excluding system ones)
            ALL_NS=$(kubectl get namespaces -o json | jq -r '.items[].metadata.name' | grep -v -E '^(kube-|default|argocd|cert-manager|ingress-nginx|external-dns|argo-rollouts)')

            ORPHANED=""
            for ns in $ALL_NS; do
              if ! echo "$MANAGED_NS" | grep -q "^${ns}$"; then
                ORPHANED="$ORPHANED $ns"
              fi
            done

            if [ -z "$ORPHANED" ]; then
              echo "âœ… No orphaned namespaces found" >> $GITHUB_STEP_SUMMARY
            else
              echo "### âš ï¸ Orphaned Namespaces Found:" >> $GITHUB_STEP_SUMMARY
              for ns in $ORPHANED; do
                POD_COUNT=$(kubectl get pods -n "$ns" --no-headers 2>/dev/null | wc -l || echo "0")
                echo "- \`$ns\` ($POD_COUNT pods)" >> $GITHUB_STEP_SUMMARY

                if [ "$DRY_RUN" == "false" ]; then
                  kubectl delete namespace "$ns" --timeout=120s || true
                  echo "  âœ… Deleted" >> $GITHUB_STEP_SUMMARY
                fi
              done
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          done

          if [ "$DRY_RUN" == "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**To actually delete orphaned namespaces, re-run with dry_run=false**" >> $GITHUB_STEP_SUMMARY
          fi

  summary:
    name: "ðŸ“Š Final Summary"
    runs-on: ubuntu-latest
    needs: [list-applications, delete-single, delete-by-prefix, delete-high-pod-apps, cleanup-orphaned]
    if: always()

    steps:
      - name: Generate Summary
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ“Š Workflow Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| List Applications | ${{ needs.list-applications.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Delete Single | ${{ needs.delete-single.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Delete by Prefix | ${{ needs.delete-by-prefix.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Delete High-Pod Apps | ${{ needs.delete-high-pod-apps.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Cleanup Orphaned | ${{ needs.cleanup-orphaned.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "*Generated by Opsera Code-to-Cloud v0.6*" >> $GITHUB_STEP_SUMMARY
