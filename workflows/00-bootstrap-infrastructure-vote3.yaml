# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# BOOTSTRAP INFRASTRUCTURE WORKFLOW - vote3
# Generated by Opsera Code-to-Cloud Enterprise v0.905
#
# This workflow provisions:
# - ECR repositories for all 3 services
# - RDS PostgreSQL database
# - ElastiCache Redis cluster
# - IRSA roles for service accounts
# - ArgoCD applications for all environments
#
# RULE 57: All AWS/kubectl commands run in GitHub Actions, never locally
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

name: "00-Bootstrap Infrastructure (vote3)"

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        type: choice
        options:
          - dev
          - qa
          - staging
          - all
        default: 'dev'
      action:
        description: 'Terraform action'
        type: choice
        options:
          - plan
          - apply
          - destroy
        default: 'apply'
      skip_terraform:
        description: 'Skip Terraform (only apply ArgoCD apps)'
        type: boolean
        default: false

env:
  APP_NAME: vote3
  AWS_REGION: us-west-2
  TENANT: opsera
  HUB_CLUSTER: argocd-usw2
  SPOKE_CLUSTER: opsera-usw2-np
  TF_VAR_aws_region: us-west-2
  TF_VAR_app_name: vote3
  TF_VAR_tenant: opsera

permissions:
  contents: write
  id-token: write

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 1: Validate Prerequisites
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  validate:
    name: "ðŸ” Validate Prerequisites"
    runs-on: ubuntu-latest
    outputs:
      environments: ${{ steps.envs.outputs.environments }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Determine Environments
        id: envs
        run: |
          if [ "${{ inputs.environment }}" == "all" ]; then
            echo 'environments=["dev","qa","staging"]' >> $GITHUB_OUTPUT
          else
            echo 'environments=["${{ inputs.environment }}"]' >> $GITHUB_OUTPUT
          fi

      - name: Validate Required Secrets
        run: |
          MISSING=""
          [ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ] && MISSING="$MISSING AWS_ACCESS_KEY_ID"
          [ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ] && MISSING="$MISSING AWS_SECRET_ACCESS_KEY"
          [ -z "${{ secrets.AWS_ACCOUNT_ID }}" ] && MISSING="$MISSING AWS_ACCOUNT_ID"
          [ -z "${{ secrets.GH_PAT }}" ] && MISSING="$MISSING GH_PAT"

          if [ -n "$MISSING" ]; then
            echo "::error::Missing required secrets:$MISSING"
            exit 1
          fi
          echo "âœ… All required secrets present"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 2: Terraform Infrastructure (ECR, RDS, ElastiCache, IRSA)
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  terraform:
    name: "ðŸ—ï¸ Terraform (${{ matrix.environment }})"
    needs: [validate]
    if: inputs.skip_terraform != true
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ fromJson(needs.validate.outputs.environments) }}
      fail-fast: false
    env:
      TF_VAR_environment: ${{ matrix.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"

      - name: Terraform Init
        working-directory: .opsera-vote3/terraform
        run: |
          terraform init \
            -backend-config="key=vote3/${{ matrix.environment }}/terraform.tfstate"

      - name: Terraform Plan
        working-directory: .opsera-vote3/terraform
        run: |
          terraform plan \
            -var-file="${{ matrix.environment }}.tfvars" \
            -out=tfplan

      - name: Terraform Apply
        if: inputs.action == 'apply'
        working-directory: .opsera-vote3/terraform
        run: |
          terraform apply -auto-approve tfplan

      - name: Terraform Destroy
        if: inputs.action == 'destroy'
        working-directory: .opsera-vote3/terraform
        run: |
          terraform destroy \
            -var-file="${{ matrix.environment }}.tfvars" \
            -auto-approve

      - name: Output Infrastructure Details
        if: inputs.action == 'apply'
        working-directory: .opsera-vote3/terraform
        run: |
          echo "### ðŸ—ï¸ Infrastructure for ${{ matrix.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| RDS Endpoint | \`$(terraform output -raw rds_address)\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Redis Endpoint | \`$(terraform output -raw elasticache_endpoint)\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Vote ECR | \`$(terraform output -raw ecr_vote_repository_url)\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Result ECR | \`$(terraform output -raw ecr_result_repository_url)\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Worker ECR | \`$(terraform output -raw ecr_worker_repository_url)\` |" >> $GITHUB_STEP_SUMMARY

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 3: Update K8s Manifests with Infrastructure Endpoints
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  update-manifests:
    name: "ðŸ“ Update Manifests (${{ matrix.environment }})"
    needs: [validate, terraform]
    if: always() && (needs.terraform.result == 'success' || inputs.skip_terraform == true) && inputs.action == 'apply'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ fromJson(needs.validate.outputs.environments) }}
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"

      - name: Get Terraform Outputs
        id: tf
        working-directory: .opsera-vote3/terraform
        run: |
          terraform init -backend-config="key=vote3/${{ matrix.environment }}/terraform.tfstate"

          echo "rds_address=$(terraform output -raw rds_address)" >> $GITHUB_OUTPUT
          echo "redis_address=$(terraform output -raw elasticache_endpoint)" >> $GITHUB_OUTPUT
          echo "vote_ecr=$(terraform output -raw ecr_vote_repository_url)" >> $GITHUB_OUTPUT
          echo "result_ecr=$(terraform output -raw ecr_result_repository_url)" >> $GITHUB_OUTPUT
          echo "worker_ecr=$(terraform output -raw ecr_worker_repository_url)" >> $GITHUB_OUTPUT
          echo "vote_irsa=$(terraform output -raw irsa_vote_role_arn)" >> $GITHUB_OUTPUT
          echo "result_irsa=$(terraform output -raw irsa_result_role_arn)" >> $GITHUB_OUTPUT
          echo "worker_irsa=$(terraform output -raw irsa_worker_role_arn)" >> $GITHUB_OUTPUT

      - name: Update ConfigMap (Environment-Specific)
        run: |
          ENV="${{ matrix.environment }}"
          CONFIGMAP=".opsera-vote3/k8s/overlays/${ENV}/configmap.yaml"

          echo "Updating ConfigMap for ${ENV}..."
          sed -i "s|PLACEHOLDER_REDIS_HOST|${{ steps.tf.outputs.redis_address }}|g" $CONFIGMAP
          sed -i "s|PLACEHOLDER_DATABASE_HOST|${{ steps.tf.outputs.rds_address }}|g" $CONFIGMAP

          echo "âœ… ConfigMap updated with:"
          echo "   Redis: ${{ steps.tf.outputs.redis_address }}"
          echo "   RDS: ${{ steps.tf.outputs.rds_address }}"

      - name: Update Service Accounts (Environment-Specific)
        run: |
          ENV="${{ matrix.environment }}"
          SA=".opsera-vote3/k8s/overlays/${ENV}/serviceaccounts.yaml"

          echo "Updating ServiceAccounts for ${ENV}..."
          sed -i "s|PLACEHOLDER_VOTE_IRSA_ROLE|${{ steps.tf.outputs.vote_irsa }}|g" $SA
          sed -i "s|PLACEHOLDER_RESULT_IRSA_ROLE|${{ steps.tf.outputs.result_irsa }}|g" $SA
          sed -i "s|PLACEHOLDER_WORKER_IRSA_ROLE|${{ steps.tf.outputs.worker_irsa }}|g" $SA

          echo "âœ… ServiceAccounts updated with IRSA roles"

      - name: Update Kustomization Images
        run: |
          ENV="${{ matrix.environment }}"
          ACCOUNT_ID="${{ secrets.AWS_ACCOUNT_ID }}"
          REGION="${{ env.AWS_REGION }}"
          ECR_REGISTRY="${ACCOUNT_ID}.dkr.ecr.${REGION}.amazonaws.com"

          echo "Updating ECR registry for ${ENV}..."

          # Update this environment's overlay kustomization
          KUST=".opsera-vote3/k8s/overlays/${ENV}/kustomization.yaml"
          sed -i "s|PLACEHOLDER_ECR_REGISTRY|${ECR_REGISTRY}|g" "$KUST"

          echo "âœ… ECR registry set to: ${ECR_REGISTRY}"

      - name: Commit Updates
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Exclude .terraform directory (contains large provider binaries)
          git add .opsera-vote3/k8s/
          git add .opsera-vote3/argocd/

          if git diff --cached --quiet; then
            echo "No changes to commit"
          else
            git commit -m "bootstrap(vote3): Update manifests for ${{ matrix.environment }} [skip ci]"
            git pull --rebase origin main
            git push origin main
          fi

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 4: Apply ArgoCD Applications
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  apply-argocd:
    name: "ðŸš€ Apply ArgoCD (${{ matrix.environment }})"
    needs: [validate, update-manifests]
    if: always() && needs.update-manifests.result == 'success' && inputs.action == 'apply'
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: ${{ fromJson(needs.validate.outputs.environments) }}
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl for Hub Cluster
        run: |
          aws eks update-kubeconfig --name ${{ env.HUB_CLUSTER }} --region ${{ env.AWS_REGION }}

      - name: Create ArgoCD Repository Secret
        run: |
          SECRET_NAME="repo-${{ env.APP_NAME }}"

          if kubectl get secret "$SECRET_NAME" -n argocd &>/dev/null; then
            echo "Repository secret already exists"
          else
            kubectl create secret generic "$SECRET_NAME" -n argocd \
              --from-literal=type=git \
              --from-literal=url="https://github.com/${{ github.repository }}.git" \
              --from-literal=password="${{ secrets.GH_PAT }}" \
              --from-literal=username="git"

            kubectl label secret "$SECRET_NAME" -n argocd \
              argocd.argoproj.io/secret-type=repository

            echo "âœ… Repository secret created"
          fi

      - name: Apply ArgoCD Application
        run: |
          APP_FILE=".opsera-vote3/argocd/${{ matrix.environment }}/application.yaml"

          if [ ! -f "$APP_FILE" ]; then
            echo "::error::Application file not found: $APP_FILE"
            exit 1
          fi

          kubectl apply -f "$APP_FILE"
          echo "âœ… ArgoCD Application applied for ${{ matrix.environment }}"

      - name: Trigger ArgoCD Sync
        run: |
          APP_NAME="${{ env.APP_NAME }}-${{ matrix.environment }}"

          # Force refresh
          kubectl annotate application "$APP_NAME" -n argocd \
            argocd.argoproj.io/refresh=hard --overwrite

          echo "âœ… ArgoCD sync triggered for $APP_NAME"

      - name: Wait for Sync
        run: |
          APP_NAME="${{ env.APP_NAME }}-${{ matrix.environment }}"

          for i in {1..30}; do
            STATUS=$(kubectl get application "$APP_NAME" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")

            echo "Sync status: $STATUS"

            if [ "$STATUS" == "Synced" ]; then
              echo "âœ… Application synced successfully"
              exit 0
            fi

            sleep 10
          done

          echo "âš ï¸ Sync still in progress - check ArgoCD UI for status"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # STAGE 5: Summary
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  summary:
    name: "ðŸ“‹ Summary"
    needs: [validate, terraform, update-manifests, apply-argocd]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate Summary
        run: |
          echo "# ðŸŽ‰ Bootstrap Complete - vote3" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Environments Bootstrapped" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          for env in ${{ inputs.environment == 'all' && 'dev qa staging' || inputs.environment }}; do
            echo "### $env" >> $GITHUB_STEP_SUMMARY
            echo "- Terraform: ${{ needs.terraform.result }}" >> $GITHUB_STEP_SUMMARY
            echo "- Manifests: ${{ needs.update-manifests.result }}" >> $GITHUB_STEP_SUMMARY
            echo "- ArgoCD: ${{ needs.apply-argocd.result }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          done

          echo "## Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. Push code changes to trigger CI/CD:" >> $GITHUB_STEP_SUMMARY
          echo "   \`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "   git push origin main" >> $GITHUB_STEP_SUMMARY
          echo "   \`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "2. Or manually trigger a build:" >> $GITHUB_STEP_SUMMARY
          echo "   \`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "   gh workflow run \"ci-build-push-vote3-dev.yaml\"" >> $GITHUB_STEP_SUMMARY
          echo "   \`\`\`" >> $GITHUB_STEP_SUMMARY
